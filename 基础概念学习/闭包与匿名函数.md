# 1. 匿名函数

匿名函数是不需要定义函数名的函数，它可以简化代码，增强代码的可读性。如果某个功能的业务逻辑比较简单，只在后续的代码块发挥作用，不需要重复使用，那么就可以把这个功能定义为匿名函数。对于业务逻辑比较复杂，需要重复使用的功能，则更适合定义为命名函数

匿名函数有3种使用方式：在定义时直接调用，将匿名函数赋值给变量，作为回调函数



1. 在定义时直接调用

    ```go
    func(m int, n int){
    	fmt.Println(m+n)
    }(10,20)
    
    // 30
    ```



2. 将匿名函数赋值给变量

    ```go
       sum := func(m int, n int) int {
            return m+n
       }
    
       fmt.Println(sum(1,2))
    
    // 3
    ```



3. 作为回调函数

    可以把匿名函数看作一个值，从而被其他函数调用

    ```go
    func handle_slice_value(s []int, f func(int)){
    	for _, v := range s{
    		f(v)
    	}
    }
    
    func main() {
    
    	s1 := []int{1,2,3,4}
    
    	handle_slice_value(s1, func(m int){
    		fmt.Println(m)
    	})	//这里的大括号和小括号并行
    
    	fmt.Println(s1)
    }
    
    //#+RESULTS:
    : 1
    : 2
    : 3
    : 4
    : [1 2 3 4]
    
    ```







# 2. 闭包

## 2.1 闭包的定义



匿名函数的一个优越性就是可以直接使用函数内的变量，不用在匿名函数里再次声明，换句话说，对于这个内部的匿名函数而言

Go 官方解释

```
Function literals are closures: they may refer to variables defined in a surrounding function. Those variables are then shared between the surrounding function and the function literal, and they survive as long as they are accessible.
```



翻译过来：

```
函数字面量是闭包:它们可以引用周围函数中定义的变量。然后，这些变量在周围的函数和函数字面量之间共享，只要它们是可访问的，它们就会存在。
```



也就是说，闭包其实就是一个函数值，但是这个函数值会引用函数体外的变量，也就是说受函数调用和引用环境的影响



```go
#+begin_src go :imports fmt

func increment(i int) func() int{
	return func() int {
		i++
		return i
	}
}

func main(){
	x := increment(0)
	fmt.Println(x())
	fmt.Println(x())
	fmt.Println(x())
	fmt.Println(x())
	x = increment(10)
	fmt.Println(x())
	fmt.Println(x())
	fmt.Println(x())
	fmt.Println(x())

	
}


#+end_src

#+RESULTS:
: 1
: 2
: 3
: 4
: 11
: 12
: 13
: 14

```



可以看到，第一次定义 x 调用自增函数后，会一直自增，而不是输出 `1 1 1 1` ，就是因为这里的 x 其实没有 “关闭” ，所以 x 的环境一直存在，闭包就会一直执行





## 2.2 闭包的应用场景

1. 状态保持

    闭包允许函数保持其内部状态，这些状态在函数多次调用之间是持久的，这种特性很适合用于实现状态机、计数器等功能

2. 延迟执行

    在处理需要延迟执行的任务，闭包可以捕获当前上下文状态，等待需要时再继续执行，这在事件处理、资源管理中特别有用

3. 函数工厂

    可以通过闭包动态生成函数，根据不同的需求生成不同的函数，这在工厂模式中常用

4. 回调函数

    当一个函数需要将处理结果传递给另一个函数进一步使用时，闭包可以封装当前处理状态并传递给回调函数















