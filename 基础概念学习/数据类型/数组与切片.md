# 1. 数组 arry

数组是具有相同且唯一的数据类型的一组数据的数据项序列：

- 也就是说数组里的元素数据类型都相同，如 int 、string，或者是自定义类型
- 数组具有索引，从 0 开始
- 数据具有固定长度，声明后长度不可更改





## 1. 定义数组

1. 声明数组： 需要说明元素类型与个数

    ```go
    var arryName[size]dataType
    
    //
    var test[20]string
    ```



> 在声明时，arry 中的每个元素都会根据其类型默认自动初始化，如果元素类型是 int，那么默认值就是 0

```GO
func main() {
	var names[5]int
	fmt.Println(names)
}
```

![image-20240710105008529](assets/image-20240710105008529.png)











2. 初始化数组： 

    使用初始化列表来初始化数组

    ```go
    var nums[5]int{1,2,3,4,5,}
    ```





3. 字面量定义数组

    ```go
    nums := [5]int{1,2,3,4,5}
    ```



4. 用 ... 代替 size： 如果不确定 arry 的长度，可以用 ... 代替，解释器会自己推算 arry 的长度

    ```go
    func main() {
    	test := [...]int{1,2,3,4,5,}
    	fmt.Println(len(test))
    }
    ```

    ![image-20240710110710159](assets/image-20240710110710159.png)







>在 GO 中，数组大小是类型的一部分，因此不同大小的数组是不兼容的，也就是说 num[5]int 和 num[10]int 也是两个不同的类型





3. 通过数组的值初始化切片

    ```go
    func slice_init() {
    	arry1 := [4]int{0,1,2,3}
    	fmt.Printf("%T \n", arry1)
    	slice1 := arry1[:]
    	fmt.Println(slice1)
    	fmt.Printf("%T", slice1)
    }
    ```

    ![image-20240712142534841](assets/image-20240712142534841.png)





## 2. 访问数组元素

1. 通过索引访问元素
2. 通过 range 遍历元素

```go
func main() {
	test := [...]int{1,2,3,4,5,}
	fmt.Println(test[0])
	fmt.Println("get all data:")
	for i := range test{
		fmt.Println(i)
	}
}
```

![image-20240710111445661](assets/image-20240710111445661.png)





3. 通过循环访问索引遍历元素

    ```go
    func main() {
    	test := [...]int{1,2,3,4,5,}
    	fmt.Println(test[0])
    	fmt.Println("get all data by index:")
    	for i := 0; i<5; i++{
    		fmt.Println(test[i])
    	}
    }
    ```

    ![image-20240710111806256](assets/image-20240710111806256.png)







# 2. 多维数组

Go 支持多维数组，声明方式：

```go
var arryName[size1][size2][sizeN] dataType

var test[5][6]int
```





## 1. 二维数组

1. 声明 arry

    ```go
    var arryName[x][y]dataType
    ```

​	二维数组的本质就是一堆一维数组组成的

![img](assets/go-array-2021-01-19.png)



​	二维数组可以理解为一个嵌套数组，也就是数组的元素类型本身也是数组（切片）罢了



>这里刚好可以说明，为什么数组的长度也是类型的一部分（`[10]int` 和 `[20]int` 是两个不同的类型），如果类型忽略数组的长度的话，那多维数组的 row 和 column 将不统一，例如子切片1是10个元素，子切片2是20个元素，那么多维数组的 row 长度为 2，但是 column 长度就会无法确定是 10 还是 20，因此需要底层数组的个数来指明



2. 初始化二维数组

    ```go
    test := [3][4]int{
        {0,1,2,3},
        {4,5,6,7},
    }
    ```

    >最后一个元素后面必须有逗号；
    >
    >或者将右花括号与最后一个元素并行写，最后一个元素后就可以不写逗号

    

    

3. 访问元素

    ```go
    func main() {
        // 二维切片
    	test := [][]int{}
        // a1 a2 都是切片
    	a1 := []int{1,2,3,4}
    	a2 := []int{5,6,7,8}
    	test = append(test, a1)
    	test = append(test, a2)
    	fmt.Println("get all test data by index:")
    	for i := 0; i<2; i++{
    		fmt.Println(test[i])
    	}
    	fmt.Println("get a1[3]")
    	fmt.Println(test[0][3])
    }
    ```

    ![image-20240710114728991](assets/image-20240710114728991.png)

    







# 3. 切片 slice



前文提到，数组的长度是固定不可变的，那显然这在特定场合中是不适用的，因此 Go 还提供了一种更加灵活强悍的动态数组--切片

- 切片是对数组的抽象
- 长度不固定，可以追加元素
- 定义切片不需要说明长度



## 1. 定义切片

1. 声明未指定大小的切片

    ```go
    var sliceName[]type
    ```



2. 使用 make() 定义切片

    ```go
    var sliceName[]Tyep = make([]type, len)
    ```

    eg.

    ```go
    func main() {
    	var s1[]int = make([]int, 6)
    	fmt.Println(len(s1))
    }
    ```

    ![image-20240710145050728](assets/image-20240710145050728.png)

还可以写为：

```go
s1 := make([]int, 6)
```





3. 定义容量

    ```go
    make([]T, length, capacity)
    ```

    - T 是切片的元素类型
    - len 是切片的长度，表示切片元素的个数
    - capacity 是切片的容量，表示切片底层数组中元素的个数，容量可以省略，省略时容量等于长度

    ```go
    func main() {
    	s1 := make([]int, 5, 10)
    	fmt.Println(len(s1))
    	fmt.Println(cap(s1))
    }
    ```

    ![image-20240710145755757](assets/image-20240710145755757.png)

    - 这里说明 s1 是一个长度为 5，容量为 10 的整型切片；
    - 即使 s1 的长度为 5，但底层数组的实际容量为 10，也就是说可以在不重新分配内存的前提下，将最多 10 个元素添加进切片中



> 可以理解为长度表示当前切片中实际存储的元素个数，容量表示在不扩展内存的情况下，能存储的最大元素个数





## 2. 切片应用

### 2.1 append()：slice 的容量扩展

通过 `append` 函数向 slice 里追加元素

1. 当指定元素长度，append 的元素超过 len 时

```go
func main() {
	s1 := make([]int, 3)
	s1 = append(s1, 1)
	s1 = append(s1, 2)
	s1 = append(s1, 3)
	s1 = append(s1, 4)
	fmt.Println(len(s1))
	fmt.Println(cap(s1))
	for i := 0; i<len(s1); i++{
		fmt.Println(s1[i])
	}
}

```

![image-20240710151019951](assets/image-20240710151019951.png)



- 说明切片的长度超过了初始定义的容量后，切片会自动扩展底层数组



>从头部添加元素会引起内存的重分配，导致已有元素全部复制一次。因此从头部添加元素的开销要比从尾部添加元素大很多



- 容量的用途

    当切片的当前长度超过了容量时，go 就会自动扩展底层数组的容量。但因为这涉及到重新分配内存和复制元素，所以动态扩展容量其实是一个昂贵的操作，所以它会依照一定的动态扩展规则，尽可能的收束频繁申请内存带来的消耗

    换句话说，容量的作用就是在执行 append 这样的操作时，来判断是否需要更换新的底层数组，如果新的长度超过了原有底层数组的长度，就申请内存，更换底层数组，舍弃原有数组，并将原来的元素值拷贝到新的底层数组，如果没有操作就不更换，从而实现在数据拷贝和内存（申请或占用）消耗之间的一种平衡



- 为什么扩展后的容量是 12  -->  容量的扩展规则

    [部分源码](https://github.com/golang/go/blob/dfaaa91f0537f806a02ff2dd71b79844cd16cc4e/src/runtime/slice.go#L177)：

    - newcap： 最终的新容量
    - oldcap：原有容量
    - cap：新要扩容的容量

    ```go
    newcap := old.cap
    doublecap := newcap + newcap
    if cap > doublecap {
            newcap = cap
    } else {
            if old.cap < 1024 {
                    newcap = doublecap
            } else {
                    // Check 0 < newcap to detect overflow
                    // and prevent an infinite loop.
                    for 0 < newcap && newcap < cap {
                            newcap += newcap / 4
                    }
                    // Set newcap to the requested cap when
                    // the newcap calculation overflowed.
                    if newcap <= 0 {
                            newcap = cap
                    }
            }
    }
    ```

    >- 新申请扩容的容量大于旧容量的 2 倍，就用传入的新申请容量
    >
    >- 新申请扩容的容量小于等于旧容量的2倍
    >    - 旧容量小于 1024，就直接让新容量为旧容量的2倍
    >    - 旧容量大于等于 1024，新容量就扩展旧容量的四分之一

    

    - 如果需要扩容的容量大于原有容量的2倍，那新容量就会为这个旧容量的2倍，例如这里原有容量是 3，当 append 了第一个元素后，容量就需要扩展，此时扩展到 4，是不大于 6 的，因此会走 else 里的逻辑，此时 3 < 1024，所以新容量为 6
    - 继续 append，一直到 append 4 时，又需要扩容，依然是上面的逻辑，扩展到 12，已经能够装下 append 的 7 个元素和原有的 3 个元素，不需要继续扩展





### 2.2 copy() ：复制切片数据

函数签名：

```go
func copy(dst, src []T) int
```

- dst 是目标切片
- src 就是源切片
- T 是切片数据类型



1. 复制完整的切片数据

    ```go
    func main() {
    	s4 := []int{0,1,2,3,4,5,6}
    	s5 := make([]int, len(s4))
    	copy(s5, s4)
    	fmt.Println(s4)
    	fmt.Println(s5)
    }
    ```

    ![image-20240711151927193](assets/image-20240711151927193.png)





2. 复制部分

    ```go
    func main() {
    	s4 := []int{0,1,2,3,4,5,6}
    	s5 := make([]int, 4)
    	copy(s5, s4[:4])
    	fmt.Println(s4)
    	fmt.Println(s5)
    }
    ```

    ![image-20240711152038871](assets/image-20240711152038871.png)



3. copy 的返回值

    ```org-mode
    #+begin_src go :imports fmt
    s1 := []int{1,2,3,4,5,6}
    s2 := make([]int, 5)
    s3 := make([]int, 10)
    x := copy(s2, s1)
    y := copy(s3, s1)
    fmt.Println(s2)
    fmt.Println(x)
    fmt.Println(y)
    #+end_src
    
    
    #+RESULTS:
    : [1 2 3 4 5]
    : 5
    : 6
    
    ```

    可以看到，当源 slice 超过目标 slice 长度时，会按照长度小的 slice 进行复制，并不会报错，而 copy 函数实际上也有返回值，返回的就是两个 slice 里长度更小的那个 slice 的长度





## 3. nil 与空切片

- nil 切片，其内存地址是空地址，nil 切片和 nil 相等
- 空切片，切片指针指向一个具体的内存地址，和 nil 不相等，通常用来表示一个空的集合

### 3.1 空切片（Empty Slice）：

空切片是指一个长度为 0 的切片，可以使用 `make` 函数创建一个空切片，例如：

```go
emptySlice := make([]int, 0)
```

或者直接使用切片字面量创建空切片：

```go
emptySlice := []int{}
```

空切片在内存中分配了切片结构，但没有分配任何元素的存储空间。它在实际使用中非常有用，用于表示集合为空的情况，也可以作为函数的返回值来避免返回 `nil`。



特点：

- `len(emptySlice)` 的值为 0。
- 可以直接对空切片进行切片操作，如 `emptySlice[1:3]`，结果仍为空切片。
- 内存中有一个指向空数组的指针，因此占用的内存很小。





示例用途：

空切片可以作为一种通用的空集合表示方式，例如：

```go
func emptyIntSlice() []int {
    return []int{}
}

func main() {
    var data []int
    if len(data) == 0 {
        fmt.Println("Data is empty")
    }

    emptyData := emptyIntSlice()
    if len(emptyData) == 0 {
        fmt.Println("Empty data is also empty")
    }
}
```



### 3.2 nil 切片（Nil Slice）：

nil 切片是一个特殊的切片值，表示切片未初始化。在 Go 中，切片的零值就是 `nil`，可以通过以下方式声明一个 nil 切片：

```go
var nilSlice []int
```

或者使用 `nil` 字面量来初始化一个 nil 切片：

```go
nilSlice := []int(nil)
```

nil 切片在内存中没有分配任何空间，它不指向任何有效的数组。当需要表示一个空的切片时，通常使用空切片而不是 nil 切片。



特点：

- `len(nilSlice)` 的值为 0。
- `nilSlice == nil` 是 true。
- 不可以进行任何切片操作，如 `nilSlice[1:3]` 会导致运行时错误（panic）。



示例用途：

通常情况下，nil 切片表示切片未初始化或者没有有效数据，例如：

```go
var data []int

if data == nil {
    fmt.Println("Data is nil")
}

// 这里 data 还没有被初始化，所以它是 nil 切片
```

### 总结：

- **空切片**用于表示一个长度为 0 的切片，内部分配了切片结构，但没有分配任何元素的存储空间。
- **nil 切片**表示一个未初始化的切片，不指向任何有效的数组，通常用于表示切片未初始化或者没有有效数据。
- 通常情况下，应优先使用空切片来表示空集合，避免使用 nil 切片引发运行时错误。





## 4. 截取切片

和 `python` 一样，可以通过 `[start:end]` 来截取部分元素，并且都是左闭右开区间

```go
func main() {
	s3 := []int{0,1,2,3,4,5,6}
	fmt.Println(s3[:5])
	fmt.Println(s3[1:3])

}
```

![image-20240711150731623](assets/image-20240711150731623.png)







## 5. 删除切片元素

实际上， Go 并没有提供删除 slice 元素的函数，但是既然切片可以通过 [:] 来截取，那么就可以变相实现元素的去除

```go
a = []int{1, 2, 3}
//删除尾部元素
a = a[:len(a) - 1]                //删除尾部一个元素
a = a[:len(a) - N]                //删除尾部N个元素
//删除头部元素
a = [1:]                        //删除开头1个元素
a = [N:]                        //删除开头N个元素
//删除中间元素
a = append(a[:i], a[i+1:]...)    //删除中间一个元素
a = append(a[:i], a[i+N:]...)    //删除中间N个元素
```









## 6. 切片的底层

Go 的数组是值类型，当作为函数的参数传递时，实际上是将对应数组复制一份，因此传递效率是没有指针高的

而切片是对数组的再次封装，是引用类型，因此在传递切片时会引用同一份指针，切片的数据结构：

```go
type slice struct {
    array unsafe.Pointer    //指向底层数组的指针
    len int                    //切片长度
    cap int                    //切片容量
}
```

- 指针指向底层数组的地址，也是切片开始的位置



### 切片元素的内存地址

```go
q1 := [3]int{1,2,3}
fmt.Println("The first quarter months have:")
for mon := range q1 {
	fmt.Println(q1[mon])
}

spring := q1[:3]
fmt.Println("Spring in:")
for i := range spring {
	fmt.Println(spring[i])
}

fmt.Println("then modify spring[2] form 3 to 4")
spring[2] = 4
fmt.Println("After modify spring in:")
for i := range spring {
	fmt.Println(spring[i])
}
fmt.Println("After modify Q1 have:")
for mon := range q1 {
	fmt.Println(q1[mon])
}
```



运行结果：

![image-20240712163249232](assets/image-20240712163249232.png)



- 实际上切片并不是拷贝了数组的数据，而是将指针指向底层数组里第一个可以访问的元素的地址（不一定是数组的第一个元素）
- 切片与原数组或切片共享底层空间，也就是修改一个，就会影响其他的变量





